using System;
using System.Collections;
using System.Collections.Generic;
using AnyPath.Graphs.HexGrid;
using AnyPath.Managed;
using AnyPath.Managed.Finders;
using AnyPath.Managed.Results;
using AnyPath.Native;
using AnyPath.Native.Util;
using Unity.Mathematics;
using UnityEngine;
using Random = UnityEngine.Random;

namespace AnyPath.Examples
{

    /*
     * These are the finders types our snakes use. The definitions were generated by using the AnyPath Code Generator.
     * (Window > AnyPath Code Generator)
     *
     * NOTE: you *must* provide a concrete implementation with the goal type (TOption, the first type argument) can not be left open
     * because the burst compiler will *NOT* be able to compile the pathfinding job in a standalone build.
     */
    
    public interface IHexGridOptionFinder<out TResult> : IOptionFinder<HexGridGoal, HexGrid, HexGridCell, TResult>  { }
    public class HexGridOptionFinder : OptionFinder<HexGridGoal, HexGrid, HexGridCell, HexGridHeuristicProvider, NoEdgeMod<HexGridCell>, NoProcessing<HexGridCell>, HexGridCell>, IHexGridOptionFinder<Path<HexGridGoal, HexGridCell>> { }
    public class HexGridCheapestOptionFinder : CheapestOptionFinder<HexGridGoal, HexGrid, HexGridCell, HexGridHeuristicProvider, NoEdgeMod<HexGridCell>, NoProcessing<HexGridCell>, HexGridCell>, IHexGridOptionFinder<Path<HexGridGoal, HexGridCell>> { }
    public class HexGridPriorityOptionFinder: PriorityOptionFinder<HexGridGoal, HexGrid, HexGridCell, HexGridHeuristicProvider, NoEdgeMod<HexGridCell>, NoProcessing<HexGridCell>, HexGridCell>, IHexGridOptionFinder<Path<HexGridGoal, HexGridCell>> { }

    
    public class Snake : MonoBehaviour, IComparer<HexGridGoal>
    {
        [SerializeField] private float stepDuration = .05f;
        
        // Our different finder types, which one we use depends on the GoalFindMethod as found on HexGridExample.cs
        // Since we're using one finder per snake, we can set ReuseResult to true, minimizing GC pressure
        private HexGridOptionFinder optionFinder = new HexGridOptionFinder() { ReuseResult = true };
        private HexGridCheapestOptionFinder cheapestFinder = new HexGridCheapestOptionFinder() { ReuseResult = true };
        private HexGridPriorityOptionFinder priorityFinder = new HexGridPriorityOptionFinder() { ReuseResult = true };
        
        // Events the tail responds to
        public event Action<Vector3Int> Moved;
        public event Action ReachedGoal;
        
        private void Start()
        {
            // initialize all of our finders with the same validator and reserver.
            optionFinder.SetValidator(HexGridGoalValidator.Instance).SetReserver(HexGridGoalValidator.Instance);
            cheapestFinder.SetValidator(HexGridGoalValidator.Instance).SetReserver(HexGridGoalValidator.Instance);
            priorityFinder
                .SetValidator(HexGridGoalValidator.Instance)
                .SetReserver(HexGridGoalValidator.Instance)
                // the priority finder needs a comparison function which is defined below
                .SetComparer(this);

            StartCoroutine(SnakeLoop());
        }
        
        // this comparison function will be used by the PriorityFinder to sort goals in descending priority order
        // if you want the lowest numbers to go first, just flip x and y
        public int Compare(HexGridGoal x, HexGridGoal y) => y.Priority.CompareTo(x.Priority);

        public static int live;
        
        /// <summary>
        /// Main loop of the snake
        /// </summary>
        IEnumerator SnakeLoop()
        {
            var waitRetry = new WaitForSeconds(Random.Range(.25f, .50f));
            int gridVersion;
            
            while (true)
            {
                // grid version increments when the grid is randomized, invalidating our path
                gridVersion = HexGridExample.GridVersion;
                var currentPosition = HexGridExample.TransformToNode(transform);
                
                // get our current finder (as an interface, so we can use the same code for all finder types)
                var finder = GetFinder(HexGridExample.GoalFindMethod);
                
                // clear the finder before (re)use. but keep the validators etc. intact
                finder.Clear(ClearFinderFlags.KeepValidatorReserverAndComparer);
                
                // assign the current grid and add all of the goals that exist as options
                finder
                    .SetGraph(HexGridExample.HexGrid)
                    .AddOptions(HexGridGoal.All, currentPosition, goal => HexGridExample.TransformToNode(goal.transform));

                yield return finder.Schedule();

                // the result we get back will have selected one of the goals that was validated, reserved and for which a path exists
                if (!finder.Result.HasPath)
                {
                    // wait for a bit and try again
                    yield return waitRetry;
                    continue;
                }

                // actually move along the found path
                yield return FollowPath(finder.Result, gridVersion);
            }
        }
        
        IEnumerator FollowPath(Path<HexGridGoal, HexGridCell> path, int gridVersion)
        {
            var waitStep = new WaitForSeconds(stepDuration);
            
            // our result contains the goal that was chosen for this snake. We can know for certain that it's reachable
            // and that no other snake is seeking it, because we've used the validator and reserver defined in HexGridGoalValidator.cs
            var target = path.Option;

            // display our path
            foreach (var edge in path)
            {
                // stop following path if target was destroyed
                if (target == null)
                    yield break;
                
                // stop if grid changed
                if (HexGridExample.GridVersion != gridVersion)
                {
                    target.IsSeeked = false; // free up target
                    yield break;
                }

                MoveTo(edge);
                yield return waitStep;
            }

            // we've reached our goal
            ReachedGoal?.Invoke();
            target.OnReached(); // this will destroy the target
        }
        
        // selects the finder to use depending on the dropdown setting
        // because we return it as an interface, we can use the same code to build our request
        private IOptionFinder<HexGridGoal, HexGrid, HexGridCell, Path<HexGridGoal, HexGridCell>> GetFinder(GoalFindMethod method)
        {
            switch (method)
            {
                case GoalFindMethod.Priority:
                    return priorityFinder;
                case GoalFindMethod.Cheapest:
                    return cheapestFinder;
                case GoalFindMethod.Any:
                    return optionFinder;
            }

            throw new NotSupportedException();
        }
        
        /// <summary>
        /// Moves this gameobject and invokes the moved event, which the tail uses to update itself
        /// </summary>
        public void MoveTo(int2 cell)
        {
            transform.position = HexGridExample.TileMap.CellToWorld(cell.ToVector3Int());
            Moved?.Invoke(cell.ToVector3Int()); // the tail colors the tiles
        }
    }
}